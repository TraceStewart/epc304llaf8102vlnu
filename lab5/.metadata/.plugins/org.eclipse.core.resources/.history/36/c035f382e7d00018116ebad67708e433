//*****************************************************************************
//
// main_spi_lis3dh.c - Example demonstrating how to configure SSI0 in SPI master
// mode to read accelerometer data from LIS3DH sensor.
//
// Copyright (c) 2010-2011 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
//
// Texas Instruments (TI) is supplying this software for use solely and
// exclusively on TI's microcontroller products. The software is owned by
// TI and/or its suppliers, and is protected under applicable copyright
// laws. You may not combine this software with "viral" open-source
// software in order to form a larger program.
//
// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES, FOR ANY REASON WHATSOEVER.
//
// This is part of revision 8034 of the Stellaris Firmware Development Package.
//
//*****************************************************************************
#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_memmap.h"
#include "inc/hw_ssi.h"
#include "inc/hw_types.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/ssi.h"
#include "driverlib/gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"

#include "utils/uartstdio.h"

//*****************************************************************************
//
//! \addtogroup ssi_examples_list
//! <h1>SPI Master (spi_master)</h1>
//!
//! This example shows how to configure the SSI0 as SPI Master.  The code will
//! send three characters on the master Tx then polls the receive FIFO until
//! 3 characters are received on the master Rx.
//!
//! This example uses the following peripherals and I/O signals.  You must
//! review these and change as needed for your own board:
//! - SSI0 peripheral
//! - GPIO Port A peripheral (for SSI0 pins)
//! - SSI0CLK - PA2
//! - SSI0Fss - PA3
//! - SSI0Rx  - PA4
//! - SSI0Tx  - PA5
//!
//! The following UART signals are configured only for displaying console
//! messages for this example.  These are not required for operation of SSI0.
//! - UART0 peripheral
//! - GPIO Port A peripheral (for UART0 pins)
//! - UART0RX - PA0
//! - UART0TX - PA1
//!
//! This example uses the following interrupt handlers.  To use this example
//! in your own application you must add these interrupt handlers to your
//! vector table.
//! - None.
//!
//
//*****************************************************************************
//*****************************************************************************
//
// The error routine that is called if the driver library encounters an error.
//
//*****************************************************************************
#ifdef DEBUG
void
__error__(char *pcFilename, uint32_t ui32Line)
{
    UARTprintf("Error at line %d of %s\n", ui32Line, pcFilename);
    while(1)
    {
    }
}
#endif

#define NUM_SSI_DATA 6 //Store 16bit of data for X,Y and Z axis
#define NUM_SSI_CFG 4 //Store Configuration Parameters

#define  LIS3DH_RANGE_16_G        0b11  // +/- 16g
#define  LIS3DH_RANGE_8_G         0b10 // +/- 8g
#define  LIS3DH_RANGE_4_G         0b01   // +/- 4g
#define  LIS3DH_RANGE_2_G         0b00    // +/- 2g (default value)

#define   LIS3DH_DATARATE_400_HZ       0b0111  //  400Hz
#define   LIS3DH_DATARATE_200_HZ       0b0110  //  200Hz
#define   LIS3DH_DATARATE_100_HZ       0b0101  //  100Hz
#define   LIS3DH_DATARATE_50_HZ        0b0100  //   50Hz
#define   LIS3DH_DATARATE_25_HZ        0b0011  //   25Hz
#define   LIS3DH_DATARATE_10_HZ        0b0010  // 10 Hz
#define   LIS3DH_DATARATE_1_HZ         0b0001  // 1 Hz
#define   LIS3DH_DATARATE_POWERDOWN    0
#define   LIS3DH_DATARATE_LOWPOWER_1K6HZ   0b1000
#define  LIS3DH_DATARATE_LOWPOWER_5KHZ    0b1001

//#define BAUD                    38400

void   InitConsole(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
    UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 115200,
                        (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
    // U can also use UARTStdioConfig to initialize the UART for console I/O.
    UARTStdioConfig(0, 115200, 16000000);
}

// uint8_t ulDataTx[NUM_SSI_DATA];
// uint8_t ulDataRx[NUM_SSI_DATA];
// uint8_t ulCFGTx[NUM_SSI_CFG];

int  main(void)
{
    uint16_t ulDataTx[NUM_SSI_DATA];
    uint16_t ulDataRx[NUM_SSI_DATA];
    uint8_t ulCFGTx[NUM_SSI_CFG];

    SysCtlClockSet(SYSCTL_SYSDIV_1 | SYSCTL_USE_OSC | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);

    InitConsole();
    UARTprintf("SSI ->\n");
    UARTprintf("Mode: SPI\n");
    UARTprintf("Data: 8-bit\n\n");
    ulDataRx[0]=1;
    //
    // The SSI0 peripheral and port A must be enabled for use.
    // Enable the SSI0 peripheral
    SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI0);
    // The SSI0 peripheral is on Port A and pins 2,3,4 and 5.
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    // This function/s configures the pin muxing on port A pins 2,3,4 and 5
    GPIOPinConfigure(GPIO_PA2_SSI0CLK);
    GPIOPinConfigure(GPIO_PA3_SSI0FSS);
    GPIOPinConfigure(GPIO_PA4_SSI0RX);
    GPIOPinConfigure(GPIO_PA5_SSI0TX);
    GPIOPinTypeSSI(GPIO_PORTA_BASE, GPIO_PIN_5 | GPIO_PIN_4 | GPIO_PIN_3 |
                   GPIO_PIN_2);
    // Deselect the Slave
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3);

    // Configure and enable the SSI port for SPI master mode.
    SSIClockSourceSet(SSI0_BASE,SSI_CLOCK_SYSTEM);
    SSIConfigSetExpClk(SSI0_BASE, SysCtlClockGet(), SSI_FRF_MOTO_MODE_0,
                       SSI_MODE_MASTER, 1000000, 8);
    SSIEnable(SSI0_BASE);
    // Read any residual data from the SSI port.
    while(SSIDataGetNonBlocking(SSI0_BASE, &ulDataRx[0]));
   // Display indication that the SSI is transmitting data.
    UARTprintf("Sent:\n  ");
    // Send the data using the "blocking" put function.
    // Initialize the data to send.
    //ulDataTx[0] = (0x0F & ~0x0C); //ASK WHO AM I?
    ulDataTx[0] = 0x0F; //ASK WHO AM I?

    //Make SSI pin low - enable slave device
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0);
    // Send data to slave to ask "Who am I"?
    SSIDataPut(SSI0_BASE,&ulDataTx[0]);
    while(SSIBusy(SSI0_BASE));
    SSIDataGet(SSI0_BASE, &ulDataRx[0]);
    // Deselect the slave
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3);
    UARTprintf(" ", ulDataRx[0]);
    if (ulDataRx[0] == 0x33)
        UARTprintf("Device ID'%X' found:\n", ulDataRx[0]);
    else
        UARTprintf("Device not found: %X \n", ulDataRx[0]);
    // Configuration Sequence
    // enable all axes, normal mode
    // 100Hz rate
    ulCFGTx[0] = 0x57;
    ulCFGTx[1] = 0x00; // High res, BDU enabled, range = 4g @ 0x21  (CTRL2)
    ulCFGTx[2] = 0x00; // DRDY on INT1 @ 0x22 (CTRL3)
    ulCFGTx[3] = 0x00; //set Range to 2Gs @ 0x24 (CTRL4)
    // Configure LIS3D
    // enable all axes, normal mode and 400Hz rate
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0); // CS = 0 enable
    SSIDataPut(SSI0_BASE,0x20 & ~0xC0);
    while(SSIBusy(SSI0_BASE)){}
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3); // CS =1 disable
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0);
    SSIDataPut(SSI0_BASE,&ulCFGTx[0]);
    while(SSIBusy(SSI0_BASE));
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3);
    // High res & BDU enabled
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0); // CS = 0 enable
    SSIDataPut(SSI0_BASE,0x23 & ~0xC0);
    while(SSIBusy(SSI0_BASE)){}
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3); // CS =1 disable
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0);
    SSIDataPut(SSI0_BASE,&ulCFGTx[1]);
    while(SSIBusy(SSI0_BASE)){}
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3);
    // DRDY on INT1
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0); // CS = 0 enable
    SSIDataPut(SSI0_BASE,0x22 & ~0xC0);
    while(SSIBusy(SSI0_BASE)){}
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3); // CS =1 disable
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0);
    SSIDataPut(SSI0_BASE,&ulCFGTx[2]);
    while(SSIBusy(SSI0_BASE)){}
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3);
    //set Range to 4Gs
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0); // CS = 0 enable
    SSIDataPut(SSI0_BASE,0x1F & ~0xC0);
    while(SSIBusy(SSI0_BASE)){}
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3); // CS =1 disable
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0);
    SSIDataPut(SSI0_BASE,&ulCFGTx[3]);
    while(SSIBusy(SSI0_BASE)){}
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3);
    //Repeat for all data registers
    while(1)
    {
     GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,0);
     //Read Data from 0x28 ... 0x2D
     SSIDataPut(SSI0_BASE,0x28|0x80); //read data
     while(SSIBusy(SSI0_BASE)){}
     SSIDataGet(SSI0_BASE, &ulDataRx[0]);
     SSIDataPut(SSI0_BASE,0x29|0x80); //read data
     while(SSIBusy(SSI0_BASE)){}
     SSIDataGet(SSI0_BASE, &ulDataRx[1]);
     SSIDataPut(SSI0_BASE,0x2A|0x80); //read data
     while(SSIBusy(SSI0_BASE)){}
     SSIDataGet(SSI0_BASE, &ulDataRx[2]);
     SSIDataPut(SSI0_BASE,0x2B|0x80); //read data
     while(SSIBusy(SSI0_BASE)){}
     SSIDataGet(SSI0_BASE, &ulDataRx[3]);
     SSIDataPut(SSI0_BASE,0x2C|0x80); //read data
     while(SSIBusy(SSI0_BASE)){}
     SSIDataGet(SSI0_BASE, &ulDataRx[4]);
     SSIDataPut(SSI0_BASE,0x2D|0x80); //read data
     while(SSIBusy(SSI0_BASE)){}
     SSIDataGet(SSI0_BASE, &ulDataRx[5]);
    GPIOPinWrite(GPIO_PORTA_BASE,GPIO_PIN_3,GPIO_PIN_3);
    // Change divisor based on range (2g=16380, 4g= 8190, 8g=4096, 16g=1365)
    UARTprintf("X-axis:'%f' ", (float) (ulDataRx[1]<<8 | ulDataRx[0])/16380);
    UARTprintf("Y-axis:'%f' ", (float) (ulDataRx[3]<<8 | ulDataRx[2])/16380);
    UARTprintf("Z-axis:'%f' \n", (float) (ulDataRx[5]<<8 | ulDataRx[4])/16380);
    }
    return(0);
}
